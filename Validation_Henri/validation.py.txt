from collections import deque


class RootedGraph:
    def __init__(self, graph, roots):
        self.graph = graph
        # DOIT ETRE UNE LISTE
        self.root = roots

    def roots(self):
        return self.root

    def neighbours(self, node):
        return self.graph[node]


class HanoiGraph(RootedGraph):
    def __init__(self, disks, root):
        self.graph = {}
        self.disks = disks
        # DOIT ETRE UNE LISTE
        self.root = root
        self.solution = tuple(2 for i in range(disks))

    def is_solution(self, node):
        return node == self.solution

    def neighbours(self, node):
        neighbours = []
        stack_finalised = [False, False, False]
        for disk, stack in enumerate(node):
            if stack_finalised[stack]:
                continue
            # Early-exit, might not be
            # if all(stack_finalised):
            #     break
            stack_finalised[stack] = True

            # Find possible moves
            if not stack_finalised[0]:
                neighbour = list(node)
                neighbour[disk] = 0
                neighbours.append(tuple(neighbour))
            if not stack_finalised[1]:
                neighbour = list(node)
                neighbour[disk] = 1
                neighbours.append(tuple(neighbour))
            if not stack_finalised[2]:
                neighbour = list(node)
                neighbour[disk] = 2
                neighbours.append(tuple(neighbour))

        return neighbours


class ParentTracer(RootedGraph):
    def __init__(self, graph):
        self.graph = graph

        self.parents = {}

        for element in graph.roots():
            self.parents[element] = None

    def roots(self):
        return self.graph.roots()

    def neighbours(self, node):
        neighbours = self.graph.neighbours(node)
        for neighbour in neighbours:
            if neighbour not in self.parents.keys():
                self.parents[neighbour] = node

        return neighbours

    def parent(self, child):
        return self.parents[child]

    def lineage(self, child):
        if child is None:
            raise ValueError("No lineage for None")

        lineage = [child]
        while child not in self.graph.roots():
            child = self.parent(child)
            lineage.append(child)

        return lineage


class Semantics:
    def initial(self):
        raise NotImplementedError

    def actions(self, configuration): 
        raise NotImplementedError

    def execute(self, configuration, action):
        # doit renvoyer une liste, donc action doivent renvoyer des listes
        return action(configuration)


class Semantics_to_RG(RootedGraph):
    def __init__(self, semantics):
        self.semantics = semantics

    def roots(self):
        return self.semantics.initial()

    def neighbours(self, node):
        neighbours = []
        # Je récupère TOUTES les actions disponibles à partir de ce noeud.
        actions = self.semantics.actions(node)
        for action in actions:
            neighbours.extend(self.semantics.execute(node, action))
        return neighbours


class AliceAndBob0(Semantics):
    def initial(self):
        return [("I", "I")]
    
    def actions (self, configuration):
        actions = []

        if (configuration[0] == "I"):
            actions.append(lambda configuration: [("W", configuration[1])])
        elif (configuration[0] == "W"):
            actions.append(lambda configuration: [("C", configuration[1])])
        elif (configuration[0] == "C"):
            actions.append(lambda configuration: [("I", configuration[1])])

        if (configuration[1] == "I"):
            actions.append(lambda configuration: [(configuration[0], "W")])
        elif (configuration[1] == "W"):
            actions.append(lambda configuration: [(configuration[0], "C")])
        elif (configuration[1] == "C"):
            actions.append(lambda configuration: [(configuration[0], "I")])

        return actions


class AliceAndBob1(Semantics):
    def initial(self):
        return [("I", "I", 0, 0)] # Alice, Bob, Alice's flag, Bob's flag
    
    def actions (self, configuration):
        actions = []

        if (configuration[0] == "I"): 
            actions.append(lambda configuration: [("W", configuration[1], 1, configuration[3])])
        elif (configuration[0] == "W" and configuration[3] == 0):
            actions.append(lambda configuration: [("C", configuration[1], configuration[2], configuration[3])])
        elif (configuration[0] == "C"):
            actions.append(lambda configuration: [("I", configuration[1], 0, configuration[3])])

        if (configuration[1] == "I"): 
            actions.append(lambda configuration: [(configuration[0], "W", configuration[2], 1)])
        elif (configuration[1] == "W" and configuration[2] == 0):
            actions.append(lambda configuration: [(configuration[0], "C", configuration[2], configuration[3])])
        elif (configuration[1] == "C"):
            actions.append(lambda configuration: [(configuration[0], "I", configuration[2], 0)])

        return actions
    
    def is_deadlock(self, configuration, action):
        return action(configuration) == []


class AliceAndBob2(Semantics):
    def initial(self):
        return [("I", "I", 0, 0)] # Alice, Bob, Alice's flag, Bob's flag
    
    def actions (self, configuration):
        actions = []

        if (configuration[0] == "I"): 
            actions.append(lambda configuration: [("W", configuration[1], 1, configuration[3])])
        elif (configuration[0] == "W" and configuration[3] == 0):
            actions.append(lambda configuration: [("C", configuration[1], configuration[2], configuration[3])])
        elif (configuration[0] == "W" and configuration[3] == 1):
            actions.append(lambda configuration: [("I", configuration[1], 0, configuration[3])])
        elif (configuration[0] == "C"):
            actions.append(lambda configuration: [("I", configuration[1], 0, configuration[3])])

        if (configuration[1] == "I"): 
            actions.append(lambda configuration: [(configuration[0], "W", configuration[2], 1)])
        elif (configuration[1] == "W" and configuration[2] == 0):
            actions.append(lambda configuration: [(configuration[0], "C", configuration[2], configuration[3])])
        elif (configuration[1] == "W" and configuration[2] == 1):
            actions.append(lambda configuration: [(configuration[0], "I", configuration[2], 0)])
        elif (configuration[1] == "C"):
            actions.append(lambda configuration: [(configuration[0], "I", configuration[2], 0)])

        return actions
    
    def is_solution(self, configuration):
        return configuration[0] == "C" and configuration[1] == "C"


class OneBitClock(Semantics):
    def initial(self):
        return [0, 1]
    
    def actions(self, configuration):
        actions = []
        if (configuration == 1):
            actions.append(lambda configuration: [0])
        if (configuration == 0):
            actions.append(lambda configuration: [1])

        return actions
    # on ne re-implemente pas is_solution, parce que OneBitCLock n'est pas censee etre parcourue
    # donc on prefere que l'erreur soit levee.


def bfs_search(rg, query):
    visited = set(rg.roots())
    queue = deque(rg.roots())

    for root in rg.roots():
        if query(root):
            return (root, visited)

    while queue:
        vertex = queue.popleft()
        for neighbour in rg.neighbours(vertex):
            if neighbour not in visited:
                if query(neighbour):
                    return (neighbour, visited)
                visited.add(neighbour)
                queue.append(neighbour)

    return (None, visited)


if __name__ == '__main__':
    ###########################################################################
    # rg = RootedGraph({1: [2, 3], 2: [3, 4], 3: [], 4: []}, [1])
    # def a(n):
    #     return n == 2

    # def b(n):
    #     return n == 5

    # print(bfs_search(rg, a))
    # print(bfs_search(rg, b))


    ###########################################################################
    # hanoi = HanoiGraph(2, [(0, 0)])
    # hanoi = HanoiGraph(3, [(0, 0, 0)])
    # print(bfs_search(hanoi, hanoi.is_solution))

    ###########################################################################
    # hanoi = HanoiGraph(3, [(0, 0, 0)])
    # parents = ParentTracer(hanoi)
    # target, visited = bfs_search(parents, hanoi.is_solution)
    # print("SEARCH target found", target)
    # print("SEARCH visited", visited)
    # print("LINEAGE", parents.lineage(target))

    ###########################################################################
    alice_and_bob = Semantics_to_RG(AliceAndBob0())
    def is_solution(configuration):
        # faire une lambda fonction pour ca ?
        # et pour vérifier les Deadlocks aussi
        return configuration == ("C", "C")
    parents = ParentTracer(alice_and_bob)
    target, visited = bfs_search(parents, is_solution)
    print("SEARCH target found", target)
    print("SEARCH visited", visited)
    if target is not None:
        print("LINEAGE", parents.lineage(target))
    else:
        print("LINEAGE target is None")

    ###########################################################################
    # alice_and_bob = Semantics_to_RG(AliceAndBob1())
    # def is_solution(configuration):
    #     return configuration[0] == "C" and configuration[1] == "C"
    # parents = ParentTracer(alice_and_bob)
    # target, visited = bfs_search(parents, is_solution)
    # print("SEARCH target found", target)
    # print("SEARCH visited", visited)
    # if target is not None:
    #     print("LINEAGE", parents.lineage(target))
    # else:
    #     print("LINEAGE target is None")
