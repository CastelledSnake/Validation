import abc
from copy import deepcopy

import validation

# Personne n'en hérite, j'ai fait quoi encore
class SoupConfiguration(abc.ABC):
    @abc.abstractmethod
    def __hash__(self):
        return super().__hash__()

    @abc.abstractmethod
    def __eq__(self, __value):
        return super().__eq__(__value)

    @abc.abstractmethod
    def __str__(self):
        return super().__str__()


class Piece():
    """garde et action sont des fonctions ou des lambdas"""
    def __init__(self, name, garde, action):
        self.name: str = name

        self.garde = garde
        self.action = action

    def __str__(self):
        return self.name

    def enabled(self, configuration):
        return self.garde(configuration)

    def execute(self, configuration):
        configuration = deepcopy(configuration)
        new_configuration = self.action(configuration)
        return [new_configuration]


class SoupSpec:
    """Prend une liste de configurations initiales et une liste de pieces et on filtre sur la garde."""
    def __init__(self, initial_configurations, pieces):
        self.initial_configurations = initial_configurations
        self.pieces = pieces

    def initial(self):
        return self.initial_configurations

    def enabledPieces(self, configuration):
        return filter(lambda p: p.enabled(configuration), self.pieces)


class SoupSemantics(validation.Semantics):
    def __init__(self, spec):
        self.spec = spec

    def initial(self):
        return self.spec.initial()

    def actions(self, configuration):
        return self.spec.enabledPieces(configuration)

    def execute(self, configuration, piece):
        return piece.execute(configuration)


class OBCConfig:
    def __init__(self, clock):
        self.clock = clock

    def __hash__(self):
        return self.clock

    def __eq__(self, other):
        return self.clock == other.clock

    def __str__(self):
        return str(self.clock)


if __name__ == '__main__':
    # p1 = Piece("1->0", lambda c: c.clock == 1, lambda c: OBCConfig(0))
    # p2 = Piece("0->1", lambda c: c.clock == 0, lambda c: OBCConfig(1))

    # soup = SoupSpec([OBCConfig(0)], [p1, p2])
    # soup_sem = SoupSemantics(soup)
    # s = validation.Semantics_to_RG(soup_sem)


    # Alice et Bob utilisant Piece
    p1 = Piece("Alice I->W", lambda c: c[0] == "I", lambda c: ("W", c[1]))
    p2 = Piece("Alice W->C", lambda c: c[0] == "W", lambda c: ("C", c[1]))
    p3 = Piece("Alice C->I", lambda c: c[0] == "C", lambda c: ("I", c[1]))
    p4 = Piece("Bob   I->W", lambda c: c[1] == "I", lambda c: (c[0], "W"))
    p5 = Piece("Bob   W->C", lambda c: c[1] == "W", lambda c: (c[0], "C"))
    p6 = Piece("Bob   C->I", lambda c: c[1] == "C", lambda c: (c[0], "I"))

    def is_solution(configuration):
        return configuration == ("C", "C")

    # import pdb; pdb.set_trace()
    # s pour step, ça entre dans les fonctions
    # n pour next, aller à la ligne d'après, ne rentre pas dans les fonctions
    # c pour continue, aller au prochain breakpoint
    soup = SoupSpec([("I", "I")], [p1, p2, p3, p4, p5, p6])
    soup_sem = SoupSemantics(soup)
    alice_and_bob = validation.Semantics_to_RG(soup_sem)
    parents = validation.ParentTracer(alice_and_bob)
    target, visited = validation.bfs_search(parents, is_solution)
    print("SEARCH target found", target)
    print("SEARCH visited", visited)
    if target is not None:
        print("LINEAGE", parents.lineage(target))
    else:
        print("LINEAGE target is None")
